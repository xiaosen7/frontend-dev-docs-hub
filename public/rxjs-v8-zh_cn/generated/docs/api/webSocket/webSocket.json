{
  "id": "api/webSocket/webSocket",
  "title": "webSocket",
  "contents": "\n\n<article>\n  <div class=\"page-actions\">\n    <a href=\"https://github.com/reactivex/rxjs/edit/master/src/internal/observable/dom/webSocket.ts?message=docs(webSocket)%3A%20describe%20your%20change...#L2-L199\" aria-label=\"编辑建议\" title=\"编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n    <a href=\"https://github.com/reactivex/rxjs/tree/8.0.0-alpha.7/src/internal/observable/dom/webSocket.ts#L2-L199\" aria-label=\"查看源码\" title=\"查看源码\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">code</i></a>\n  </div>\n    <div class=\"breadcrumb\">\n      <script type=\"application/ld+json\">\n        {\n          \"@context\": \"http://schema.org\",\n          \"@type\": \"BreadcrumbList\",\n          \"itemListElement\": [\n          { \"@type\": \"ListItem\", \"position\": 1, \"item\": { \"@id\": \"https://angular.io//api\", \"name\": \"API\" } },\n          { \"@type\": \"ListItem\", \"position\": 2, \"item\": { \"@id\": \"https://angular.io/api/webSocket\", \"name\": \"rxjs/webSocket\" } },\n          { \"@type\": \"ListItem\", \"position\": 3, \"item\": { \"@id\": \"https://angular.io/api/webSocket/webSocket\", \"name\": \"webSocket\" } }\n          ]\n        }\n      </script>\n      <a href=\"/api\">API</a> / <a href=\"api/webSocket\">rxjs/webSocket</a>\n    </div>\n  <header class=\"api-header\">\n    <h1 id=\"websocket\">webSocket<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/webSocket/webSocket#websocket\"><i class=\"material-icons\">link</i></a></h1>\n    <label class=\"api-type-label function\">function</label>\n    \n    \n    <label class=\"api-status-label stable\">稳定</label>\n    \n    \n  </header>\n  <aio-toc class=\"embedded\"></aio-toc>\n\n  <div class=\"api-body\">\n    \n  \n\n  <p class=\"short-description\"></p><p>Wrapper around the w3c-compatible WebSocket object provided by the browser.</p>\n<p>围绕浏览器提供的、与 w3c 兼容的 WebSocket 对象进行包装。</p>\n<p></p>\n  \n\n  \n\n  \n\n  <code-example language=\"ts\" hidecopy=\"true\" class=\"no-box api-heading\"> webSocket&#x3C;T>(urlConfigOrSource: string | <a href=\"api/webSocket/WebSocketSubjectConfig\" class=\"code-anchor\">WebSocketSubjectConfig</a>&#x3C;T>): <a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a>&#x3C;T></code-example>\n\n\n\n  <h4 class=\"no-anchor\" id=\"parameters\">参数</h4>\n  <table class=\"is-full-width list-table parameters-table function-overload-parameters\">\n  <tbody>\n  \n    <tr class=\"function-overload-parameter\">\n      <td class=\"param-name\">\n        <a id=\"urlConfigOrSource\"></a>\n        <code>urlConfigOrSource</code>\n      </td>\n      <td class=\"param-type\"><code>string | <a href=\"api/webSocket/WebSocketSubjectConfig\" class=\"code-anchor\">WebSocketSubjectConfig</a>&#x3C;T></code></td>\n      <td class=\"param-description\">\n      <p>        The WebSocket endpoint as an url or an object with\nconfiguration and additional Observers.</p>\n<p>WebSocket 端点作为 url 或具有配置和其它 Observer 的对象。</p>\n\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n  \n  <h4 class=\"no-anchor\" id=\"返回值\">返回值</h4>\n  <p><code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject&#x3C;T></a></code>: Subject which allows to both send and receive messages via WebSocket connection.</p>\n<p>允许通过 WebSocket 连接发送和接收消息的主体。</p>\n\n  \n\n\n\n\n\n\n\n  \n\n<section class=\"description\">\n  <h2 id=\"description\">说明<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/webSocket/webSocket#description\"><i class=\"material-icons\">link</i></a></h2>\n  <p><span class=\"informal\"><a href=\"api/index/class/Subject\"><code>Subject</code></a> that communicates with a server via WebSocket</span></p>\n<p><span class=\"informal\"><a href=\"api/index/class/Subject\"><code>Subject</code></a> 通过 WebSocket 与服务器通信</span></p>\n<p><code>webSocket</code> is a factory function that produces a <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code>,\nwhich can be used to make WebSocket connection with an arbitrary endpoint.\n<code>webSocket</code> accepts as an argument either a string with url of WebSocket endpoint, or an\n<a href=\"api/webSocket/WebSocketSubjectConfig\"><code>WebSocketSubjectConfig</code></a> object for providing additional configuration, as\nwell as Observers for tracking lifecycle of WebSocket connection.</p>\n<p><code>webSocket</code> 是一个生成 <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> 的工厂函数，可用于与任意端点建立 WebSocket 连接。<code>webSocket</code> 接受带有 WebSocket 端点 url 的字符串或 <a href=\"api/webSocket/WebSocketSubjectConfig\"><code>WebSocketSubjectConfig</code></a> 对象作为参数，用于提供额外的配置，以及用于跟踪 WebSocket 连接的生命周期的 Observer。</p>\n<p>When <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> is subscribed, it attempts to make a socket connection,\nunless there is one made already. This means that many subscribers will always listen\non the same socket, thus saving resources. If however, two instances are made of <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code>,\neven if these two were provided with the same url, they will attempt to make separate\nconnections. When consumer of a <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> unsubscribes, socket connection is closed,\nonly if there are no more subscribers still listening. If after some time a consumer starts\nsubscribing again, connection is reestablished.</p>\n<p>当 <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> 被订阅时，它会尝试建立一个 Socket 连接，除非已经建立了一个。这意味着许多订阅者将始终在同一个 Socket 上侦听，从而节省资源。但是，如果两个实例由 <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> 组成，即使这两个实例提供了相同的 url，它们也会尝试建立单独的连接。当 <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> 的消费者退订时，只有在没有更多订阅者仍在监听的情况下，才会关闭 Socket 连接。如果一段时间后消费者再次开始订阅，则重新建立连接。</p>\n<p>Once connection is made, whenever a new message comes from the server, <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> will emit that\nmessage as a value in the stream. By default, a message from the socket is parsed via <code>JSON.parse</code>. If you\nwant to customize how deserialization is handled (if at all), you can provide custom <code>resultSelector</code>\nfunction in <a href=\"api/webSocket/WebSocketSubject\"><code>WebSocketSubject</code></a>. When connection closes, stream will complete, provided it happened without\nany errors. If at any point (starting, maintaining or closing a connection) there is an error,\nstream will also error with whatever WebSocket API has thrown.</p>\n<p>一旦建立连接，每当有新消息来自服务器时，<code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> 都会将该消息作为流中的值发出。默认情况下，来自 Socket 的消息会通过 <code>JSON.parse</code> 解析。如果你想自定义如何处理反序列化（如果有的话），你可以在 <a href=\"api/webSocket/WebSocketSubject\"><code>WebSocketSubject</code></a> 中提供自定义 <code>resultSelector</code> 函数。当连接关闭时，流将完成，前提是它没有任何错误发生。如果在任何时候（启动、维护或关闭连接）出现错误，无论 WebSocket API 抛出什么，流都会出错。</p>\n<p>By virtue of being a <a href=\"api/index/class/Subject\"><code>Subject</code></a>, <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> allows for receiving and sending messages from the server. In order\nto communicate with a connected endpoint, use <code>next</code>, <code>error</code> and <code>complete</code> methods. <code>next</code> sends a value to the server, so bear in mind\nthat this value will not be serialized beforehand. Because of This, <code>JSON.stringify</code> will have to be called on a value by hand,\nbefore calling <code>next</code> with a result. Note also that if at the moment of nexting value\nthere is no socket connection (for example no one is subscribing), those values will be buffered, and sent when connection\nis finally established. <code>complete</code> method closes socket connection. <code>error</code> does the same,\nas well as notifying the server that something went wrong via status code and string with details of what happened.\nSince status code is required in WebSocket API, <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> does not allow, like regular <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a></code>,\narbitrary values being passed to the <code>error</code> method. It needs to be called with an object that has <code>code</code>\nproperty with status code number and optional <code>reason</code> property with string describing details\nof an error.</p>\n<p>由于是 <a href=\"api/index/class/Subject\"><code>Subject</code></a>，<code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> 允许从服务器接收和发送消息。为了与连接的端点通信，请使用 <code>next</code>、<code>error</code> 和 <code>complete</code> 方法。<code>next</code> 会向服务器发送一个值，请记住，该值不会事先序列化。因此，在使用某个结果调用 <code>next</code> 之前，必须手动对该值调用 <code>JSON.stringify</code>。另请注意，如果在下一个值抵达的时刻没有 Socket 连接（例如没有人订阅），则这些值将被缓冲，并在最终建立连接时发送。<code>complete</code> 方法关闭 Socket 连接。<code>error</code> 也是如此，并通过状态代码和字符串通知服务器出现问题，并提供详细信息。由于 WebSocket API 中需要状态码，因此 <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> 不允许像常规 <code><a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a></code> 一样，将任意值传给 <code>error</code> 方法。需要使用带状态代码数字的 <code>code</code> 属性和带有描述错误详情的可选字符串属性 <code>reason</code> 的对象来调用它。</p>\n<p>Calling <code>next</code> does not affect subscribers of <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> - they have no\ninformation that something was sent to the server (unless of course the server\nresponds somehow to a message). On the other hand, since calling <code>complete</code> triggers\nan attempt to close socket connection. If that connection is closed without any errors, stream will\ncomplete, thus notifying all subscribers. And since calling <code>error</code> closes\nsocket connection as well, just with a different status code for the server, if closing itself proceeds\nwithout errors, subscribed Observable will not error, as one might expect, but complete as usual. In both cases\n(calling <code>complete</code> or <code>error</code>), if process of closing socket connection results in some errors, <em>then</em> stream\nwill error.</p>\n<p>调用 <code>next</code> 不会影响 <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> 的订阅者 - 他们没有任何信息表明某些内容已发送到服务器（当然，除非服务器以某种方式响应消息）。另一方面，由于调用 <code>complete</code> 会触发关闭 Socket 连接的尝试。如果该连接在没有任何错误的情况下关闭，则此流将完成，从而通知所有订阅者。而且由于调用 <code>error</code> 也会关闭 Socket 连接（只是服务器的状态码不同），如果关闭本身没有错误，则订阅的 Observable 将不会出错（正如人们所期望的那样），但会正常完成。在这两种情况下（调用 <code>complete</code> 或 <code>error</code>），如果关闭 Socket 连接的过程导致一些错误，<em>则</em>流将出错。</p>\n<p><strong>Multiplexing</strong></p>\n<p><strong>multiplex（多路复用）</strong></p>\n<p><code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> has an additional operator, not found in other Subjects. It is called <code>multiplex</code> and it is\nused to simulate opening several socket connections, while in reality maintaining only one.\nFor example, an application has both chat panel and real-time notifications about sport news. Since these are two distinct functions,\nit would make sense to have two separate connections for each. Perhaps there could even be two separate services with WebSocket\nendpoints, running on separate machines with only GUI combining them together. Having a socket connection\nfor each functionality could become too resource expensive. It is a common pattern to have single\nWebSocket endpoint that acts as a gateway for the other services (in this case chat and sport news services).\nEven though there is a single connection in a client app, having the ability to manipulate streams as if it\nwere two separate sockets is desirable. This eliminates manually registering and unregistering in a gateway for\ngiven service and filter out messages of interest. This is exactly what <code>multiplex</code> method is for.</p>\n<p><code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code> 有一个额外的操作符，在其它 Subjects 中没有。它被称为 <code>multiplex</code>，它用于模拟打开多个 Socket 连接，而实际上只真正维护一个。例如，一个应用程序既有聊天面板，也有关于体育新闻的实时通知。由于这是两个不同的功能，因此为每个功能设置两个单独的连接是有意义的。也许甚至可以有两个具有 WebSocket 端点的单独服务，在单独的机器上运行，只有 GUI 将它们组合在一起。每个功能都有一个 Socket 连接可能会变得过于昂贵。将单个 WebSocket 端点用作其它服务（在本例中为聊天和体育新闻服务）的网关是一种常见模式。即使客户端应用程序中只有一个连接，也希望能够像处理两个单独的 Socket 一样操作流。这省去了在网关中手动注册和注销给定服务的工作，并过滤掉某些感兴趣的消息。这正是 <code>multiplex</code> 方法的用途。</p>\n<p>Method accepts three parameters. First two are functions returning subscription and unsubscription messages\nrespectively. These are messages that will be sent to the server, whenever consumer of resulting Observable\nsubscribes and unsubscribes. Server can use them to verify that some kind of messages should start or stop\nbeing forwarded to the client. In case of the above example application, after getting subscription message with proper identifier,\ngateway server can decide that it should connect to real sport news service and start forwarding messages from it.\nNote that both messages will be sent as returned by the functions, they are by default serialized using JSON.stringify, just\nas messages pushed via <code>next</code>. Also bear in mind that these messages will be sent on <em>every</em> subscription and\nunsubscription. This is potentially dangerous, because one consumer of an Observable may unsubscribe and the server\nmight stop sending messages, since it got unsubscription message. This needs to be handled\non the server or using <a href=\"api/index/function/publish\"><code>publish</code></a> on a Observable returned from 'multiplex'.</p>\n<p>方法接受三个参数。前两个分别是返回订阅和退订消息的函数。每当结果 Observable 的消费者订阅和退订时，这些消息都会发送到服务器。服务器可以使用它们来验证某种消息是应该开始还是停止转发给客户端。在上面的示例应用程序中，在获得具有适当标识符的订阅消息后，网关服务器决定它要连接到真实的体育新闻服务并开始从中转发消息。请注意，这两条消息都将作为函数返回的内容发送，默认情况下，它们会使用 JSON.stringify 进行序列化，就像通过 <code>next</code> 推送的消息一样。另请记住，这些消息会在<em>每次</em>订阅和退订时发送。这是潜在的危险，因为 Observable 的一个消费者可能会退订，并且服务器可能会停止发送消息，因为它收到了退订消息。这需要在服务器上处理，或者在从“multiplex”返回的 Observable 上使用 <a href=\"api/index/function/publish\"><code>publish</code></a>。</p>\n<p>Last argument to <code>multiplex</code> is a <code>messageFilter</code> function which should return a boolean. It is used to filter out messages\nsent by the server to only those that belong to simulated WebSocket stream. For example, server might mark these\nmessages with some kind of string identifier on a message object and <code>messageFilter</code> would return <code>true</code>\nif there is such identifier on an object emitted by the socket. Messages which returns <code>false</code> in <code>messageFilter</code> are simply skipped,\nand are not passed down the stream.</p>\n<p><code>multiplex</code> 的最后一个参数是一个 <code>messageFilter</code> 函数，它应该返回一个布尔值。它用于过滤服务器发送的消息，只发送给那些属于模拟 WebSocket 流的消息。例如，服务器可能会在消息对象上用某种字符串标识符标记这些消息，如果 Socket 发出的对象上有这样的标识符，则 <code>messageFilter</code> 将返回 <code>true</code>。在 <code>messageFilter</code> 中返回 <code>false</code> 的消息将被简单地跳过，并且不会沿着流向下传递。</p>\n<p>Return value of <code>multiplex</code> is an Observable with messages incoming from emulated socket connection. Note that this\nis not a <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code>, so calling <code>next</code> or <code>multiplex</code> again will fail. For pushing values to the\nserver, use root <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code>.</p>\n<p><code>multiplex</code> 的返回值是一个 Observable，其中包含从模拟 Socket 连接传入的消息。请注意，这不是 <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code>，因此再次调用 <code>next</code> 或 <code>multiplex</code> 将失败。要将值推送到服务器，请使用根 <code><a href=\"api/webSocket/WebSocketSubject\" class=\"code-anchor\">WebSocketSubject</a></code>。</p>\n<h2 id=\"examples\">Examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/webSocket/webSocket#examples\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"例子\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"api/webSocket/webSocket#例子\"><i class=\"material-icons\">link</i></a></h2>\n<p>Listening for messages from the server</p>\n<p>监听来自服务器的消息</p>\n<code-example language=\"ts\">\nimport { webSocket } from 'rxjs/webSocket';\n\nconst subject = webSocket('ws://localhost:8081');\n\nsubject.subscribe({\n  next: msg => console.log('message received: ' + msg), // Called whenever there is a message <a href=\"api/index/function/from\" class=\"code-anchor\">from</a> the server.\n  error: err => console.log(err), // Called if at any point WebSocket API signals some kind <a href=\"api/index/function/of\" class=\"code-anchor\">of</a> error.\n  complete: () => console.log('complete') // Called when connection is closed (for whatever reason).\n });\n</code-example>\n<p>Pushing messages to the server</p>\n<p>向服务器推送消息</p>\n<code-example language=\"ts\">\nimport { webSocket } from 'rxjs/webSocket';\n\nconst subject = webSocket('ws://localhost:8081');\n\nsubject.subscribe();\n// Note that at least one consumer has to subscribe to the created subject - otherwise \"nexted\" values will be just buffered and not sent,\n// since no connection was established!\n\nsubject.next({ message: 'some message' });\n// This will send a message to the server once a connection is made. Remember value is serialized with JSON.stringify by default!\n\nsubject.complete(); // Closes the connection.\n\nsubject.error({ code: 4000, reason: 'I think our app just broke!' });\n// Also closes the connection, but let's the server know that this closing is caused by some error.\n</code-example>\n<p>Multiplexing WebSocket</p>\n<p>多路复用 WebSocket</p>\n<code-example language=\"ts\">\nimport { webSocket } from 'rxjs/webSocket';\n\nconst subject = webSocket('ws://localhost:8081');\n\nconst observableA = subject.multiplex(\n  () => ({ subscribe: 'A' }), // When server gets this message, it will start sending messages for 'A'...\n  () => ({ unsubscribe: 'A' }), // ...and when gets this one, it will stop.\n  message => message.type === 'A' // If the function returns `true` message is passed down the stream. Skipped if the function returns false.\n);\n\nconst observableB = subject.multiplex( // And the same goes for 'B'.\n  () => ({ subscribe: 'B' }),\n  () => ({ unsubscribe: 'B' }),\n  message => message.type === 'B'\n);\n\nconst subA = observableA.subscribe(messageForA => console.log(messageForA));\n// At this moment WebSocket connection is established. Server gets '{\"subscribe\": \"A\"}' message and starts sending messages for 'A',\n// which we log here.\n\nconst subB = observableB.subscribe(messageForB => console.log(messageForB));\n// Since we already have a connection, we just send '{\"subscribe\": \"B\"}' message to the server. It starts sending messages for 'B',\n// which we log here.\n\nsubB.unsubscribe();\n// Message '{\"unsubscribe\": \"B\"}' is sent to the server, which stops sending 'B' messages.\n\nsubA.unsubscribe();\n// Message '{\"unsubscribe\": \"A\"}' makes the server stop sending messages for 'A'. Since there is no more subscribers to root <a href=\"api/index/class/Subject\" class=\"code-anchor\">Subject</a>,\n// socket connection closes.\n</code-example>\n\n</section>\n\n\n\n\n  \n\n  \n\n\n  </div>\n</article>\n\n<!-- links to this doc:\n - api/webSocket\n - api/webSocket/WebSocketSubjectConfig\n-->\n<!-- links from this doc:\n - /api\n - api/index/class/Subject\n - api/index/function/from\n - api/index/function/of\n - api/index/function/publish\n - api/webSocket\n - api/webSocket/WebSocketSubject\n - api/webSocket/WebSocketSubjectConfig\n - api/webSocket/webSocket#description\n - api/webSocket/webSocket#examples\n - api/webSocket/webSocket#websocket\n - api/webSocket/webSocket#例子\n - https://github.com/reactivex/rxjs/edit/master/src/internal/observable/dom/webSocket.ts?message=docs(webSocket)%3A%20describe%20your%20change...#L2-L199\n - https://github.com/reactivex/rxjs/tree/8.0.0-alpha.7/src/internal/observable/dom/webSocket.ts#L2-L199\n-->"
}