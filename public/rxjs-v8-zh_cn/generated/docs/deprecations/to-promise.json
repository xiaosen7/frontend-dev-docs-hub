{
  "id": "deprecations/to-promise",
  "title": "转换为 Promise（承诺）",
  "contents": "\n<div class=\"content\">\n<h1 id=\"conversion-to-promises\">Conversion to Promises<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#conversion-to-promises\"><i class=\"material-icons\">link</i></a></h1>\n<h1 id=\"转换为-promise承诺\">转换为 Promise（承诺）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#转换为-promise承诺\"><i class=\"material-icons\">link</i></a></h1>\n<p>The similarity between Observables and Promises is that both <a href=\"/guide/observable\">collections</a> may produce values over\ntime, but the difference is that Observables may produce none or more than one value, while Promises produce only one\nvalue when resolved successfully.</p>\n<p>Observables 和 Promises 的相似之处在于，随着时间的推移，这两个<a href=\"/guide/observable\">集合</a>都可能产生值，但不同之处在于 Observables 可能不产生或产生多个值，而 Promises 在成功解析时只产生一个值。</p>\n<h2 id=\"issues\">Issues<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#issues\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"问题\">问题<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#问题\"><i class=\"material-icons\">link</i></a></h2>\n<p>For this reason, in RxJS 7, the return type of the Observable's <a href=\"/api/index/class/Observable#toPromise\"><code>toPromise()</code></a>\nmethod has been fixed to better reflect the fact that Observables can yield zero values. This may be a <strong>breaking\nchange</strong> to some projects as the return type was changed from <code>Promise&#x3C;T></code> to <code>Promise&#x3C;T | undefined></code>.</p>\n<p>出于这个原因，在 RxJS 7 中，Observable 的 <a href=\"/api/index/class/Observable#toPromise\"><code>toPromise()</code></a> 方法的返回类型已被修复，以更好地反映 Observable 可以产生零个值的事实。这可能对于某些项目是<strong>重大更改</strong>，因为返回类型已从 <code>Promise&#x3C;T></code> 更改为 <code>Promise&#x3C;T | undefined></code>。</p>\n<p>Also, <code>toPromise()</code> method name was never indicating what emitted value a Promise will resolve with because Observables\ncan produce multiple values over time. When converting to a Promise, you might want to choose which value to pick -\neither the first value that has arrived or the last one. To fix all these issues, we decided to deprecate <code>toPromise()</code>,\nand to introduce the two new helper functions for conversion to Promises.</p>\n<p>此外，<code>toPromise()</code> 这个方法名无法指出 Promise 将使用什么发出的值来解决（resolve），因为 Observables 可以随着时间的推移产生多个值。转换为 Promise 时，你可能需要选择要选取的值 - 是抵达的第一个值还是最后一个值。为了解决所有这些问题，我们决定弃用 <code>toPromise()</code>，并引入两个新的辅助函数来转换为 Promise。</p>\n<h2 id=\"use-one-of-the-two-new-functions\">Use one of the two new functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#use-one-of-the-two-new-functions\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"使用两个新函数之一\">使用两个新函数之一<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#使用两个新函数之一\"><i class=\"material-icons\">link</i></a></h2>\n<p>As a replacement to the deprecated <code>toPromise()</code> method, you should use one of the two built in static conversion\nfunctions <a href=\"api/index/function/firstValueFrom\"><code>firstValueFrom</code></a> or <a href=\"api/index/function/lastValueFrom\"><code>lastValueFrom</code></a>.</p>\n<p>作为已弃用的 <code>toPromise()</code> 方法的替代品，你你要改用两个内置静态转换函数 <a href=\"api/index/function/firstValueFrom\"><code>firstValueFrom</code></a> 或 <a href=\"api/index/function/lastValueFrom\"><code>lastValueFrom</code></a> 之一。</p>\n<h3 id=\"lastvaluefrom\"><code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#lastvaluefrom\"><i class=\"material-icons\">link</i></a></h3>\n<p>The <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> is almost exactly the same as <code>toPromise()</code> meaning that it will resolve with the last value that has\narrived when the Observable completes, but with the difference in behavior when Observable completes without emitting a\nsingle value. When Observable completes without emitting, <code>toPromise()</code> will successfully resolve with <code>undefined</code> (thus\nthe return type change), while the <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> will reject with the <a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a>. Thus, the return type of the\n<code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> is <code>Promise&#x3C;T></code>, just like <code>toPromise()</code> had in RxJS 6.</p>\n<p><code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> 几乎与 <code>toPromise()</code> 完全相同，这意味着它将解析为 Observable 完成时到达的最后一个值，但是如果 Observable 完成时没有发出单个值，则行为有所不同。当 Observable 完成但没有发出任何值时， <code>toPromise()</code> 将成功解析为 <code>undefined</code> （因此返回类型不同），而 <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> 将拒绝（reject）并返回 <a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a>。因此， <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> 的返回类型是 <code>Promise&#x3C;T></code> ，就像 RxJS 6 中的 <code>toPromise()</code> 一样。</p>\n<h4 id=\"example\">Example<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#example\"><i class=\"material-icons\">link</i></a></h4>\n<h4 id=\"例子\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#例子\"><i class=\"material-icons\">link</i></a></h4>\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>, <a href=\"api/index/function/take\" class=\"code-anchor\">take</a>, <a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a> } from 'rxjs';\n\nasync function execute() {\n  const source$ = <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>(2000).pipe(<a href=\"api/index/function/take\" class=\"code-anchor\">take</a>(10));\n  const finalNumber = await <a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a>(source$);\n  console.log(`The final number is ${finalNumber}`);\n}\n\nexecute();\n\n// Expected output:\n// \"The final number is 9\"\n</code-example>\n<h3 id=\"firstvaluefrom\"><code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#firstvaluefrom\"><i class=\"material-icons\">link</i></a></h3>\n<p>However, you might want to take the first value as it arrives without waiting an Observable to complete, thus you can\nuse <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code>. The <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> will resolve a Promise with the first value that was emitted from the\nObservable and will immediately unsubscribe to retain resources. The <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> will also reject with an\n<a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a> if the Observable completes with no values emitted.</p>\n<p>但是，你可能希望在第一个值到达时获取它而无需等待 Observable 完成，此时你可以使用 <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> 。 <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> 将使用从 Observable 发出的第一个值解析 Promise，并将立即取消订阅以保留资源。如果 Observable 完成但没有发出任何值，<code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> 也会拒绝（reject）并返回 <a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a>。</p>\n<h4 id=\"example-1\">Example<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#example-1\"><i class=\"material-icons\">link</i></a></h4>\n<h4 id=\"例子-1\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#例子-1\"><i class=\"material-icons\">link</i></a></h4>\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>, <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a> } from 'rxjs';\n\nasync function execute() {\n  const source$ = <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>(2000);\n  const firstNumber = await <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a>(source$);\n  console.log(`The <a href=\"api/index/function/first\" class=\"code-anchor\">first</a> number is ${firstNumber}`);\n}\n\nexecute();\n\n// Expected output:\n// \"The <a href=\"api/index/function/first\" class=\"code-anchor\">first</a> number is 0\"\n</code-example>\n<p><span class=\"informal\">Both functions will return a Promise that rejects if the source Observable errors. The Promise\nwill reject with the same error that the Observable has errored with.</span></p>\n<p><span class=\"informal\">如果源 Observable 出错，这两个函数都将返回一个拒绝的 Promise。 Promise 将拒绝并返回与 Observable 相同的错误。</span></p>\n<h2 id=\"use-default-value\">Use default value<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#use-default-value\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"使用默认值\">使用默认值<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#使用默认值\"><i class=\"material-icons\">link</i></a></h2>\n<p>If you don't want Promises created by <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> or <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> to reject with <a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a> if there\nwere no emissions before completion, you can use the second parameter. The second parameter is expected to be an object\nwith <code>defaultValue</code> parameter. The value in the <code>defaultValue</code> will be used to resolve a Promise when source Observable\ncompletes without emitted values.</p>\n<p>如果你不希望由 <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> 或 <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> 创建的 Promise 在完成前没有发送任何值时以 <a href=\"api/index/interface/EmptyError\"><code>EmptyError</code></a> 调用 reject，则可以使用第二个参数。第二个参数应该是一个带有 <code>defaultValue</code> 参数的对象。 <code>defaultValue</code> 中的值将用于在源 Observable 完成但没有发出值时解析 Promise。</p>\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a>, <a href=\"api/index/const/EMPTY\" class=\"code-anchor\">EMPTY</a> } from 'rxjs';\n\nconst result = await <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a>(<a href=\"api/index/const/EMPTY\" class=\"code-anchor\">EMPTY</a>, { defaultValue: 0 });\nconsole.log(result);\n\n// Expected output:\n// 0\n</code-example>\n<h2 id=\"warning\">Warning<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#warning\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"警告\">警告<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#警告\"><i class=\"material-icons\">link</i></a></h2>\n<p>Only use <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> function if you <em>know</em> an Observable will eventually complete. The <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> function should\nbe used if you <em>know</em> an Observable will emit at least one value <em>or</em> will eventually complete. If the source Observable\ndoes not complete or emit, you will end up with a Promise that is hung up, and potentially all of the state of an async\nfunction hanging out in memory. To avoid this situation, look into adding something like <a href=\"api/index/function/timeout\"><code>timeout</code></a>, <a href=\"api/index/function/take\"><code>take</code></a>,\n<a href=\"api/index/function/takeWhile\"><code>takeWhile</code></a>, or <a href=\"api/index/function/takeUntil\"><code>takeUntil</code></a> amongst others.</p>\n<p>仅当你<em>确信</em> Observable 最终会完成时才使用 <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> 函数。如果你<em>确信</em> Observable 将至少发出一个值<em>或</em>最终一定会完成，则应使用 <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> 函数。如果源 Observable 没有完成或发出值，你将以挂起的 Promise 结束，并且可能所有异步函数的状态都挂起在内存中。为避免这种情况，请考虑添加诸如 <a href=\"api/index/function/timeout\"><code>timeout</code></a>、<a href=\"api/index/function/take\"><code>take</code></a>、<a href=\"api/index/function/takeWhile\"><code>takeWhile</code></a> 或 <a href=\"api/index/function/takeUntil\"><code>takeUntil</code></a> 等内容。</p>\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /api/index/class/Observable#toPromise\n - /guide/observable\n - api/index/const/EMPTY\n - api/index/function/first\n - api/index/function/firstValueFrom\n - api/index/function/interval\n - api/index/function/lastValueFrom\n - api/index/function/take\n - api/index/function/takeUntil\n - api/index/function/takeWhile\n - api/index/function/timeout\n - api/index/interface/EmptyError\n - deprecations/to-promise#conversion-to-promises\n - deprecations/to-promise#example\n - deprecations/to-promise#example-1\n - deprecations/to-promise#firstvaluefrom\n - deprecations/to-promise#issues\n - deprecations/to-promise#lastvaluefrom\n - deprecations/to-promise#use-default-value\n - deprecations/to-promise#use-one-of-the-two-new-functions\n - deprecations/to-promise#warning\n - deprecations/to-promise#使用两个新函数之一\n - deprecations/to-promise#使用默认值\n - deprecations/to-promise#例子\n - deprecations/to-promise#例子-1\n - deprecations/to-promise#警告\n - deprecations/to-promise#转换为-promise承诺\n - deprecations/to-promise#问题\n-->"
}