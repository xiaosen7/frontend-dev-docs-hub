{
  "id": "guide/testing/marble-testing",
  "title": "用弹珠图测试 RxJS 代码",
  "contents": "\n<div class=\"content\">\n<h1 id=\"testing-rxjs-code-with-marble-diagrams\">Testing RxJS Code with Marble Diagrams<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#testing-rxjs-code-with-marble-diagrams\"><i class=\"material-icons\">link</i></a></h1>\n<h1 id=\"用弹珠图测试-rxjs-代码\">用弹珠图测试 RxJS 代码<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#用弹珠图测试-rxjs-代码\"><i class=\"material-icons\">link</i></a></h1>\n<div class=\"alert is-helpful\">\n<p><span>This guide refers to usage of marble diagrams when using the new <code>testScheduler.run(callback)</code>. Some details here do not apply to using the TestScheduler manually, without using the <code>run()</code> helper.</span></p>\n<p><span>本指南讲了在使用新的 <code>testScheduler.run(callback)</code> 时弹珠图的用法。这里的一些细节不适合手动使用 TestScheduler（不借助 <code>run()</code> 辅助器）。</span></p>\n</div>\n<p>We can test our <em>asynchronous</em> RxJS code <em>synchronously</em> and deterministically by virtualizing time using the TestScheduler. <strong>Marble diagrams</strong> provide a visual way for us to represent the behavior of an Observable. We can use them to assert that a particular Observable behaves as expected, as well as to create <a href=\"https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\">hot and cold Observables</a> we can use as mocks.</p>\n<p>我们可以通过使用 TestScheduler 虚拟化时间来<em>同步</em>并以确定性的方式测试我们的<em>异步</em> RxJS 代码。<strong>弹珠图</strong>为我们提供了一种可视化的方式来表示 Observable 的行为。我们可以使用它们来断言特定的 Observable 的行为符合预期，以及创建一些可以用作模拟（mock）的<a href=\"https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\">冷或热 Observable</a>。</p>\n<blockquote>\n<p>At this time, the TestScheduler can only be used to test code that uses RxJS schedulers - <code>AsyncScheduler</code>, etc. If the code consumes a Promise, for example, it cannot be reliably tested with <code><a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a></code>, but instead should be tested more traditionally. See the <a href=\"guide/testing/marble-testing#known-issues\">Known Issues</a> section for more details.</p>\n<p>此时，TestScheduler 只能用于测试使用了 RxJS 调度器 - <code>AsyncScheduler</code> 等的代码。例如，如果代码使用 Promise，则无法使用 <code><a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a></code> 可靠地进行测试，而应该用更传统地方式进行测试。有关更多详细信息，请参阅<a href=\"guide/testing/marble-testing#known-issues\">已知问题</a>部分。</p>\n</blockquote>\n<code-example language=\"ts\">\nimport { <a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a> } from 'rxjs/testing';\nimport { <a href=\"api/index/function/throttleTime\" class=\"code-anchor\">throttleTime</a> } from 'rxjs';\n\nconst testScheduler = new <a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a>((actual, expected) => {\n  // asserting the two objects are equal - required\n  // for <a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a> assertions to work via your test framework\n  // e.g. <a href=\"api/index/function/using\" class=\"code-anchor\">using</a> chai.\n  expect(actual).deep.equal(expected);\n});\n\n// This test runs synchronously.\nit('generates the stream correctly', () => {\n  testScheduler.run((helpers) => {\n    const { cold, time, expectObservable, expectSubscriptions } = helpers;\n    const e1 = cold(' -a--b--c---|');\n    const e1subs = '  ^----------!';\n    const t = time('   ---|       '); // t = 3\n    const expected = '-a-----c---|';\n\n    expectObservable(e1.pipe(<a href=\"api/index/function/throttleTime\" class=\"code-anchor\">throttleTime</a>(t))).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n  });\n});\n</code-example>\n<h2 id=\"api\">API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#api\"><i class=\"material-icons\">link</i></a></h2>\n<p>The callback function you provide to <code>testScheduler.run(callback)</code> is called with <code>helpers</code> object that contains functions you'll use to write your tests.</p>\n<p>你提供给 <code>testScheduler.run(callback)</code> 的回调函数是使用 <code>helpers</code> 对象调用的，该对象包含你将用于编写测试的函数。</p>\n<div class=\"alert is-helpful\">\n<p>When the code inside this callback is being executed, any operator that uses timers/AsyncScheduler (like delay, debounceTime, etc.,) will automatically use the TestScheduler instead, so that we have \"virtual time\". You do not need to pass the TestScheduler to them, like in the past.</p>\n<p>当此回调函数中的代码被执行时，任何使用了定时器/AsyncScheduler 的操作符（例如 delay、debounceTime 等）将会自动改用 TestScheduler，这样我们就有了「虚拟时间」。你不需要把 TestScheduler 传给它们，就像刚才一样。</p>\n</div>\n<code-example language=\"ts\">\ntestScheduler.run((helpers) => {\n  const { cold, hot, expectObservable, expectSubscriptions, flush, time, animate } = helpers;\n  // use them\n});\n</code-example>\n<p>Although <code>run()</code> executes entirely synchronously, the helper functions inside your callback function do not! These functions <strong>schedule assertions</strong> that will execute either when your callback completes or when you explicitly call <code>flush()</code>. Be wary of calling synchronous assertions, for example <code>expect</code>, from your testing library of choice, from within the callback. See <a href=\"guide/testing/marble-testing#synchronous-assertion\">Synchronous Assertion</a> for more information on how to do this.</p>\n<p>尽管 <code>run()</code> 完全同步执行，但回调函数中的辅助函数却不是这样！这些函数会<strong>调度断言</strong>，这些断言将在你的回调完成或你显式调用 <code>flush()</code> 时执行。在回调中从你选择的测试库中调用同步断言时（例如 <code>expect</code>）要多加小心。有关如何执行此操作的更多信息，请参阅<a href=\"guide/testing/marble-testing#synchronous-assertion\">同步断言</a>。</p>\n<ul>\n<li>\n<p><code>cold(marbleDiagram: string, values?: object, error?: any)</code> - creates a \"cold\" observable whose subscription starts when the test begins.</p>\n<p><code>cold(marbleDiagram: string, values?: object, error?: any)</code> - 创建一个 \"冷的\" observable，它的订阅在测试开始时开始。</p>\n</li>\n<li>\n<p><code>hot(marbleDiagram: string, values?: object, error?: any)</code> - creates a \"hot\" observable (like a subject) that will behave as though it's already \"running\" when the test begins. An interesting difference is that <code>hot</code> marbles allow a <code>^</code> character to signal where the \"zero frame\" is. That is the point at which the subscription to observables being tested begins.</p>\n<p><code>hot(marbleDiagram: string, values?: object, error?: any)</code> - 创建一个“热的” observable（比如主体 Subject），当测试开始时，它的行为就像它已经“在运行”了一样。一个有趣的区别是 <code>hot</code> 弹珠允许用 <code>^</code> 字符表示“零帧”在哪里。这就是订阅被测试的 observables 的开始。</p>\n</li>\n<li>\n<p><code>expectObservable(actual: <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>&#x3C;T>, subscriptionMarbles?: string).toBe(marbleDiagram: string, values?: object, error?: any)</code> - schedules an assertion for when the TestScheduler flushes. Give <code>subscriptionMarbles</code> as parameter to change the schedule of subscription and unsubscription. If you don't provide the <code>subscriptionMarbles</code> parameter it will subscribe at the beginning and never unsubscribe. Read below about subscription marble diagram.</p>\n<p><code>expectObservable(actual: <a href=\"api/index/class/Observable\" class=\"code-anchor\">Observable</a>&#x3C;T>, subscriptionMarbles?: string).toBe(marbleDiagram: string, values?: object, error?: any)</code> - 当 TestScheduler 刷新时安排一个断言。通过 <code>subscriptionMarbles</code> 参数来改变订阅和退订的时间表。如果你不提供 <code>subscriptionMarbles</code> 参数，它将在开始时订阅并且永远不会退订。阅读以下有关订阅弹珠图的信息。</p>\n</li>\n<li>\n<p><code>expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]).toBe(subscriptionMarbles: string)</code> - like <code>expectObservable</code> schedules an assertion for when the testScheduler flushes. Both <code>cold()</code> and <code>hot()</code> return an observable with a property <code>subscriptions</code> of type <code>SubscriptionLog[]</code>. Give <code>subscriptions</code> as parameter to <code>expectSubscriptions</code> to assert whether it matches the <code>subscriptionsMarbles</code> marble diagram given in <code>toBe()</code>. Subscription marble diagrams are slightly different than Observable\nmarble diagrams. Read more below.</p>\n<p><code>expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]).toBe(subscriptionMarbles: string)</code> - 像 <code>expectObservable</code> 一样，当 testScheduler 刷新时安排一个断言。<code>cold()</code> 和 <code>hot()</code> 都返回一个带有 <code>subscriptions</code> 属性的 observable，其类型为 <code>SubscriptionLog[]</code>。将 <code>subscriptions</code> 作为参数提供给 <code>expectSubscriptions</code> 以断言它是否与 <code>toBe()</code> 中给出的 <code>subscriptionsMarbles</code> 弹珠图匹配。订阅弹珠图与 Observable 弹珠图略有不同。在下面阅读更多内容。</p>\n</li>\n<li>\n<p><code>flush()</code> - immediately starts virtual time. Not often used since <code>run()</code> will automatically flush for you when your callback returns, but in some cases you may wish to flush more than once or otherwise have more control.</p>\n<p><code>flush()</code> - 立即开始虚拟时间。不经常使用，因为当你的回调返回时 <code>run()</code> 会自动为你刷新，但在某些情况下，你可能希望多次刷新或以其它方式取得更多控制权。</p>\n</li>\n<li>\n<p><code>time()</code> - converts marbles into a number indicating number of frames. It can be used by operators expecting a specific timeout. It measures time based on the position of the complete (<code>|</code>) signal:</p>\n<p><code>time()</code> - 将弹珠转换为表示帧数的数字。期望指定超时时间的操作符可以使用它。它根据完成信号 ( <code>|</code> ) 的位置测量时间：</p>\n<code-example language=\"ts\">\ntestScheduler.run((helpers) => {\n  const { time, cold } = helpers;\n  const source = cold('---a--b--|');\n  const t = time('        --|    ');\n  //                         --|\n  const expected = '   -----a--b|';\n  const result = source.pipe(<a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a>(t));\n  expectObservable(result).toBe(expected);\n});\n</code-example>\n</li>\n<li>\n<p><code>animate()</code> - specifies when requested animation frames will be 'painted'. <code>animate</code> accepts a marble diagram and each value emission in the diagram indicates when a 'paint' occurs - at which time, any queued <code>requestAnimationFrame</code> callbacks will be executed. Call <code>animate</code> at the beginning of your test and align the marble diagrams so that it's clear when the callbacks will be executed:</p>\n<p><code>animate()</code> - 指定何时“绘制”所请求的动画帧。<code>animate</code> 接受一个弹珠图，图中的每个值在发出时都会指示何时发生“绘制” - 届时，将执行任何已排队的 <code>requestAnimationFrame</code> 回调。在测试开始时调用 <code>animate</code> 并对齐弹珠图，以便清楚何时执行回调：</p>\n<code-example language=\"ts\">\ntestScheduler.run((helpers) => {\n  const { animate, cold } = helpers;\n  animate('              ---x---x---x---x');\n  const requests = cold('-r-------r------');\n  /* ... */\n  const expected = '     ---a-------b----';\n});\n</code-example>\n</li>\n</ul>\n<h2 id=\"marble-syntax\">Marble syntax<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#marble-syntax\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"弹珠语法\">弹珠语法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#弹珠语法\"><i class=\"material-icons\">link</i></a></h2>\n<p>In the context of TestScheduler, a marble diagram is a string containing special syntax representing events happening over virtual time. Time progresses by <em>frames</em>. The first character of any marble string always represents the <em>zero frame</em>, or the start of time. Inside of <code>testScheduler.run(callback)</code> the frameTimeFactor is set to 1, which means one frame is equal to one virtual millisecond.</p>\n<p>在 TestScheduler 的上下文中，弹珠图是一个字符串，其中包含表示随着虚拟时间发生的事件的特殊语法。时间会按<em>帧</em>前进。任何弹珠字符串的第一个字符总是代表<em>零帧</em>或者说时间的起点。在 <code>testScheduler.run(callback)</code> 内部，frameTimeFactor 设置为 1，这意味着一帧等于一个虚拟毫秒。</p>\n<p>How many virtual milliseconds one frame represents depends on the value of <code><a href=\"api/testing/TestScheduler#frameTimeFactor\" class=\"code-anchor\">TestScheduler.frameTimeFactor</a></code>. For legacy reasons the value of <code>frameTimeFactor</code> is 1 <em>only</em> when your code inside the <code>testScheduler.run(callback)</code> callback is running. Outside of it, it's set to 10. This will likely change in a future version of RxJS so that it is always 1.</p>\n<p>一帧代表多少虚拟毫秒取决于 <code><a href=\"api/testing/TestScheduler#frameTimeFactor\" class=\"code-anchor\">TestScheduler.frameTimeFactor</a></code> 的值。由于遗留原因，<em>只有</em>当 <code>testScheduler.run(callback)</code> 回调中的代码正在运行时，<code>frameTimeFactor</code> 的值才为 1。在此之外，它设置为 10。这一点可能会在 RxJS 的未来版本中发生变化，以便让它始终为 1。</p>\n<blockquote>\n<p>IMPORTANT: This syntax guide refers to usage of marble diagrams when using the new <code>testScheduler.run(callback)</code>. The semantics of marble diagrams when using the TestScheduler manually are different, and some features like the new time progression syntax are not supported.</p>\n<p>重要提示：本语法指南是指在使用新的 <code>testScheduler.run(callback)</code> 时使用弹珠图。手动使用 TestScheduler 时弹珠图的语义不同，并且不支持新的时间进度语法等某些功能。</p>\n</blockquote>\n<ul>\n<li>\n<p><code>' '</code> whitespace: horizontal whitespace is ignored, and can be used to help vertically align multiple marble diagrams.</p>\n<p><code>' '</code> 空白：忽略水平空白，可用于帮助垂直对齐多个弹珠图。</p>\n</li>\n<li>\n<p><code>'-'</code> frame: 1 \"frame\" of virtual time passing (see above description of frames).</p>\n<p><code>'-'</code> 帧：1 个虚拟时间流逝的“帧”（参见上面的帧描述）。</p>\n</li>\n<li>\n<p><code>[0-9]+[ms|s|m]</code> time progression: the time progression syntax lets you progress virtual time by a specific amount. It's a number, followed by a time unit of <code>ms</code> (milliseconds), <code>s</code> (seconds), or <code>m</code> (minutes) without any space between them, e.g. <code>a 10ms b</code>. See <a href=\"guide/testing/marble-testing#time-progression-syntax\">Time progression syntax</a> for more details.</p>\n<p><code>[0-9]+[ms|s|m]</code> 时间进度：时间进度语法允许你将虚拟时间推进特定的数量。它是一个数字，后跟 <code>ms</code>（毫秒）、<code>s</code>（秒）或 <code>m</code>（分钟）的时间单位，它们之间没有任何空格，例如 <code>a 10ms b</code>。有关更多详细信息，请参阅<a href=\"guide/testing/marble-testing#time-progression-syntax\">时间进度语法</a>。</p>\n</li>\n<li>\n<p><code>'|'</code> complete: The successful completion of an observable. This is the observable producer signaling <code>complete()</code>.</p>\n<p><code>'|'</code> 完成：一个 Observable 的成功完成。这是 Observable 的生产者信号 <code>complete()</code>。</p>\n</li>\n<li>\n<p><code>'#'</code> error: An error terminating the observable. This is the observable producer signaling <code>error()</code>.</p>\n<p><code>'#'</code> 错误：终止 observable 的错误。这是 Observable 的生产者信号 <code>error()</code>。</p>\n</li>\n<li>\n<p><code>[a-z0-9]</code> e.g. <code>'a'</code> any alphanumeric character: Represents a value being emitted by the producer signaling <code>next()</code>. Also consider that you could map this into an object or an array like this:</p>\n<p><code>[a-z0-9]</code>（例如 <code>'a'</code>）任何字母数字字符：表示由生产者信号 <code>next()</code> 发出的值。你可以将它映射到一个对象或数组中，如下所示：</p>\n</li>\n</ul>\n<!-- prettier-ignore -->\n<code-example language=\"ts\">\nconst expected = '400ms (a-b|)';\nconst values = {\n  a: 'value emitted',\n  b: 'another value emitted',\n};\n\nexpectObservable(someStreamForTesting).toBe(expected, values);\n\n// This would work also\nconst expected = '400ms (0-1|)';\nconst values = [\n  'value emitted',\n  'another value emitted'\n];\n\nexpectObservable(someStreamForTesting).toBe(expected, values);\n</code-example>\n<ul>\n<li>\n<p><code>'()'</code> sync groupings: When multiple events need to be in the same frame synchronously, parentheses are used to group those events. You can group next'd values, a completion, or an error in this manner. The position of the initial <code>(</code> determines the time at which its values are emitted. While it can be counter-intuitive at first, after all the values have synchronously emitted time will progress a number of frames equal to the number of ASCII characters in the group, including the parentheses.\ne.g. <code>'(abc)'</code> will emit the values of a, b, and c synchronously in the same frame and then advance virtual time by 5 frames, <code>'(abc)'.length === 5</code>. This is done because it often helps you vertically align your marble diagrams, but it's a known pain point in real-world testing. <a href=\"guide/testing/marble-testing#known-issues\">Learn more about known issues</a>.</p>\n<p><code>'()'</code> 同步分组：当多个事件需要同步在同一帧中时，括号用于对这些事件进行分组。你可以通过这种方式对下一个值、完成或错误进行分组。初始值 <code>(</code> 的位置决定了它的值被发出的时间。虽然一开始有点反直觉，但在所有值同步发出后，时间将前进的帧数等于组中的 ASCII 字符数, 包括括号。例如 <code>'(abc)'</code> 将在同一帧中同步发出 a、b 和 c 的值，然后将虚拟时间提前 5 帧，<code>'(abc)'.length === 5</code>。这么做是因为它通常可以帮助你垂直对齐弹珠图，这是实际测试中的一个已知痛点。<a href=\"guide/testing/marble-testing#known-issues\">了解有关已知问题</a>的更多信息。</p>\n</li>\n<li>\n<p><code>'^'</code> subscription point: (hot observables only) shows the point at which the tested observables will be subscribed to the hot observable. This is the \"zero frame\" for that observable, every frame before the <code>^</code> will be negative. Negative time might seem pointless, but there are in fact advanced cases where this is necessary, usually involving ReplaySubjects.</p>\n<p><code>'^'</code> 订阅点：（仅限热的 observables）显示被测试的 observables 将订阅热 observable 的时间点。这是该 Observable 的“零帧”，<code>^</code> 之前的每一帧都是负数。负时间可能看起来毫无意义，但实际上在高级情况下这是必要的，这通常和 ReplaySubject 有关。</p>\n</li>\n</ul>\n<h3 id=\"time-progression-syntax\">Time progression syntax<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#time-progression-syntax\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"时间进展语法\">时间进展语法<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#时间进展语法\"><i class=\"material-icons\">link</i></a></h3>\n<p>The new time progression syntax takes inspiration from the CSS duration syntax. It's a number (integer or floating point) immediately followed by a unit; ms (milliseconds), s (seconds), m (minutes). e.g. <code>100ms</code>, <code>1.4s</code>, <code>5.25m</code>.</p>\n<p>新的时间进度语法是从 CSS 持续时间语法中汲取的灵感。它是一个数字（整数或浮点数），后面紧跟一个单位：ms（毫秒）、s（秒）、m（分钟）。例如 <code>100ms</code>、<code>1.4s</code>、<code>5.25m</code>。</p>\n<p>When it's not the first character of the diagram it must be padded a space before/after to disambiguate it from a series of marbles. e.g. <code>a 1ms b</code> needs the spaces because <code>a1msb</code> will be interpreted as <code>['a', '1', 'm', 's', 'b']</code> where each of these characters is a value that will be next()'d as-is.</p>\n<p>当它不是图表的第一个字符时，必须在之前/之后填充一个空格，以消除它与一系列弹珠的歧义。例如 <code>a 1ms b</code> 需要空格，因为 <code>a1msb</code> 将被解释为 <code>['a', '1', 'm', 's', 'b']</code> 其中每个字符都是 next() 的原样值。</p>\n<p><strong>NOTE</strong>: You may have to subtract 1 millisecond from the time you want to progress because the alphanumeric marbles (representing an actual emitted value) <em>advance time 1 virtual frame</em> themselves already, after they emit. This can be counter-intuitive and frustrating, but for now it is indeed correct.</p>\n<p><strong>注意</strong>：你可能需要从你想要前进的时间中减去 1 毫秒，因为字母数字弹珠（代表实际发出的值）在它们发出后自身已经<em>提前了 1 个虚拟帧</em>。这可能是反直觉和令人沮丧的，但目前它确实是正确的。</p>\n<!-- prettier-ignore -->\n<code-example language=\"ts\">\nconst input = ' -a-b-c|';\nconst expected = '-- 9ms a 9ms b 9ms (c|)';\n\n// Depending on your personal preferences you could also\n// use frame dashes to keep vertical alignment with the input.\n// const input = ' -a-b-c|';\n// const expected = '------- 4ms a 9ms b 9ms (c|)';\n// or\n// const expected = '-----------a 9ms b 9ms (c|)';\n\nconst result = cold(input).pipe(\n  <a href=\"api/index/function/concatMap\" class=\"code-anchor\">concatMap</a>((d) => <a href=\"api/index/function/of\" class=\"code-anchor\">of</a>(d).pipe(\n    <a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a>(10)\n  ))\n);\n\nexpectObservable(result).toBe(expected);\n</code-example>\n<h3 id=\"examples\">Examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#examples\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"例子\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#例子\"><i class=\"material-icons\">link</i></a></h3>\n<p><code>'-'</code> or <code>'------'</code>: Equivalent to <a href=\"api/index/const/NEVER\"><code>NEVER</code></a>, or an observable that never emits or errors or completes.</p>\n<p><code>'-'</code> 或 <code>'------'</code> ：等价于 <a href=\"api/index/const/NEVER\"><code>NEVER</code></a>，或者是一个“从不发出”、“错误”或“完成”的 Observable。</p>\n<p><code>|</code>: Equivalent to <a href=\"api/index/const/EMPTY\"><code>EMPTY</code></a>, or an observable that never emits and completes immediately.</p>\n<p><code>|</code> : 等价于 <a href=\"api/index/const/EMPTY\"><code>EMPTY</code></a>，或者是一个永远不会立即发出和完成的 observable。</p>\n<p><code>#</code>: Equivalent to <a href=\"api/index/function/throwError\"><code>throwError</code></a>, or an observable that never emits and errors immediately.</p>\n<p><code>#</code> ：等价于 <a href=\"api/index/function/throwError\"><code>throwError</code></a>，或者是一个永远不会立即发出错误的 Observable。</p>\n<p><code>'--a--'</code>: An observable that waits 2 \"frames\", emits value <code>a</code> on frame 2 and then never completes.</p>\n<p><code>'--a--'</code> ：一个等待 2 个“帧”的 Observable，在第 2 帧上发出值 <code>a</code> 然后永远不会完成。</p>\n<p><code>'--a--b--|'</code>: On frame 2 emit <code>a</code>, on frame 5 emit <code>b</code>, and on frame 8, <code>complete</code>.</p>\n<p><code>'--a--b--|'</code> ：在第 2 帧发出 <code>a</code>，在第 5 帧发出 <code>b</code>，在第 8 帧 <code>complete</code>。</p>\n<p><code>'--a--b--#'</code>: On frame 2 emit <code>a</code>, on frame 5 emit <code>b</code>, and on frame 8, <code>error</code>.</p>\n<p><code>'--a--b--#'</code> ：在第 2 帧发出 <code>a</code>，在第 5 帧发出 <code>b</code>，在第 8 帧发出 <code>error</code>。</p>\n<p><code>'-a-^-b--|'</code>: In a hot observable, on frame -2 emit <code>a</code>, then on frame 2 emit <code>b</code>, and on frame 5, <code>complete</code>.</p>\n<p><code>'-a-^-b--|'</code> ：在一个热 observable 中，在 -2 帧上发出 <code>a</code>，然后在第 2 帧上发出 <code>b</code>，在第 5 帧上 <code>complete</code>。</p>\n<p><code>'--(abc)-|'</code>: on frame 2 emit <code>a</code>, <code>b</code>, and <code>c</code>, then on frame 8, <code>complete</code>.</p>\n<p><code>'--(abc)-|'</code> ：在第 2 帧发出 <code>a</code>、<code>b</code> 和 <code>c</code>，然后在第 8 帧，<code>complete</code>。</p>\n<p><code>'-----(a|)'</code>: on frame 5 emit <code>a</code> and <code>complete</code>.</p>\n<p><code>'-----(a|)'</code> ：在第 5 帧发出 <code>a</code> 并 <code>complete</code>。</p>\n<p><code>'a 9ms b 9s c|'</code>: on frame 0 emit <code>a</code>, on frame 10 emit <code>b</code>, on frame 9,011 emit <code>c</code>, then on frame 9,012 <code>complete</code>.</p>\n<p><code>'a 9ms b 9s c|'</code> ：在第 0 帧发出 <code>a</code>，在第 10 帧发出 <code>b</code>，在第 9,011 帧发出 <code>c</code>，然后在第 9,012 帧 <code>complete</code>。</p>\n<p><code>'--a 2.5m b'</code>: on frame 2 emit <code>a</code>, on frame 150,003 emit <code>b</code> and never complete.</p>\n<p><code>'--a 2.5m b'</code> ：在第 2 帧发出 <code>a</code>，在第 150,003 帧发出 <code>b</code> 并且永远不会完成。</p>\n<h2 id=\"subscription-marbles\">Subscription marbles<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#subscription-marbles\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"订阅弹珠\">订阅弹珠<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#订阅弹珠\"><i class=\"material-icons\">link</i></a></h2>\n<p>The <code>expectSubscriptions</code> helper allows you to assert that a <code>cold()</code> or <code>hot()</code> Observable you created was subscribed/unsubscribed to at the correct point in time. The <code>subscriptionMarbles</code> parameter to <code>expectObservable</code> allows your test to defer subscription to a later virtual time, and/or unsubscribe even if the observable being tested has not yet completed.</p>\n<p><code>expectSubscriptions</code> 帮助器允许你断言所创建的 <code>cold()</code> 或 <code>hot()</code> Observable 会在正确的时间点被订阅/退订。<code>expectObservable</code> 的 <code>subscriptionMarbles</code> 参数允许你的测试将订阅推迟到以后的虚拟时间，和/或退订，即使正在测试的 observable 尚未完成。</p>\n<p>The subscription marble syntax is slightly different to conventional marble syntax.</p>\n<p>订阅弹珠语法与传统弹珠语法略有不同。</p>\n<ul>\n<li>\n<p><code>'-'</code> time: 1 frame time passing.</p>\n<p><code>'-'</code> 时间：1 帧时间过去。</p>\n</li>\n<li>\n<p><code>[0-9]+[ms|s|m]</code> time progression: the time progression syntax lets you progress virtual time by a specific amount. It's a number, followed by a time unit of <code>ms</code> (milliseconds), <code>s</code> (seconds), or <code>m</code> (minutes) without any space between them, e.g. <code>a 10ms b</code>. See <a href=\"guide/testing/marble-testing#time-progression-syntax\">Time progression syntax</a> for more details.</p>\n<p><code>[0-9]+[ms|s|m]</code> 时间进度：时间进度语法允许你将虚拟时间推进特定数量。它是一个数字，后跟 <code>ms</code>（毫秒）、<code>s</code>（秒）或 <code>m</code>（分钟）的时间单位，它们之间没有任何空格，例如 <code>a 10ms b</code>。有关更多详细信息，请参阅<a href=\"guide/testing/marble-testing#time-progression-syntax\">时间进度语法</a>。</p>\n</li>\n<li>\n<p><code>'^'</code> subscription point: shows the point in time at which a subscription happens.</p>\n<p><code>'^'</code> 订阅点：显示订阅发生的时间点。</p>\n</li>\n<li>\n<p><code>'!'</code> unsubscription point: shows the point in time at which a subscription is unsubscribed.</p>\n<p><code>'!'</code> 退订点：显示退订的时间点。</p>\n</li>\n</ul>\n<p>There should be <strong>at most one</strong> <code>^</code> point in a subscription marble diagram, and <strong>at most one</strong> <code>!</code> point. Other than that, the <code>-</code> character is the only one allowed in a subscription marble diagram.</p>\n<p>订阅弹珠图<strong>中应该最多有一个</strong> <code>^</code> 点，<strong>最多有一个</strong> <code>!</code> 点。除此之外，<code>-</code> 字符是订阅弹珠图中唯一允许的字符。</p>\n<h3 id=\"examples-1\">Examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#examples-1\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"例子-1\">例子<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#例子-1\"><i class=\"material-icons\">link</i></a></h3>\n<p><code>'-'</code> or <code>'------'</code>: no subscription ever happened.</p>\n<p><code>'-'</code> 或 <code>'------'</code> ：从未发生过订阅。</p>\n<p><code>'--^--'</code>: a subscription happened after 2 \"frames\" of time passed, and the subscription was not unsubscribed.</p>\n<p><code>'--^--'</code> ：订阅发生在 2 “帧”时间过去后，并且此订阅没有退订。</p>\n<p><code>'--^--!-'</code>: on frame 2 a subscription happened, and on frame 5 was unsubscribed.</p>\n<p><code>'--^--!-'</code> ：在第 2 帧发生了订阅，在第 5 帧被取消了订阅。</p>\n<p><code>'500ms ^ 1s !'</code>: on frame 500 a subscription happened, and on frame 1,501 was unsubscribed.</p>\n<p><code>'500ms ^ 1s !'</code> ：在第 500 帧发生了订阅，在第 1,501 帧被取消了订阅。</p>\n<p>Given a hot source, test multiple subscribers that subscribe at different times:</p>\n<p>给定一个热的来源，测试在不同时间订阅的多个订阅者：</p>\n<code-example language=\"ts\">\ntestScheduler.run(({ hot, expectObservable }) => {\n  const source = hot('--a--a--a--a--a--a--a--');\n  const sub1 = '      --^-----------!';\n  const sub2 = '      ---------^--------!';\n  const expect1 = '   --a--a--a--a--';\n  const expect2 = '   -----------a--a--a-';\n\n  expectObservable(source, sub1).toBe(expect1);\n  expectObservable(source, sub2).toBe(expect2);\n});\n</code-example>\n<p>Manually unsubscribe from a source that will never complete:</p>\n<p>手动退订永远不会完成的源：</p>\n<code-example language=\"ts\">\nit('should <a href=\"api/index/function/repeat\" class=\"code-anchor\">repeat</a> forever', () => {\n  const testScheduler = createScheduler();\n\n  testScheduler.run(({ expectObservable }) => {\n    const foreverStream$ = <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>(1).pipe(<a href=\"api/index/function/mapTo\" class=\"code-anchor\">mapTo</a>('a'));\n\n    // Omitting this arg may crash the test suite.\n    const unsub = '------!';\n\n    expectObservable(foreverStream$, unsub).toBe('-aaaaa');\n  });\n});\n</code-example>\n<h2 id=\"synchronous-assertion\">Synchronous Assertion<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#synchronous-assertion\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"同步断言\">同步断言<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#同步断言\"><i class=\"material-icons\">link</i></a></h2>\n<p>Sometimes, we need to assert changes in state <em>after</em> an observable stream has completed - such as when a side effect like <code><a href=\"api/index/function/tap\" class=\"code-anchor\">tap</a></code> updates a variable. Outside of Marbles testing with TestScheduler, we might think of this as creating a delay or waiting before making our assertion.</p>\n<p>有时，我们需要在可观察流完成<em>之后</em>断言状态的变更 - 例如像 <code><a href=\"api/index/function/tap\" class=\"code-anchor\">tap</a></code> 这样的操作符在副作用中更新了变量时。在使用 TestScheduler 进行弹珠测试之外，我们可能会认为这是在做出断言之前造成延迟或等待。</p>\n<p>For example:</p>\n<p>例如：</p>\n<code-example language=\"ts\">\nlet eventCount = 0;\n\nconst s1 = cold('--a--b|', { a: 'x', b: 'y' });\n\n// side effect <a href=\"api/index/function/using\" class=\"code-anchor\">using</a> '<a href=\"api/index/function/tap\" class=\"code-anchor\">tap</a>' updates a variable\nconst result = s1.pipe(<a href=\"api/index/function/tap\" class=\"code-anchor\">tap</a>(() => eventCount++));\n\nexpectObservable(result).toBe('--a--b|', { a: 'x', b: 'y' });\n\n// flush - run 'virtual time' to complete all outstanding hot or cold observables\nflush();\n\nexpect(eventCount).toBe(2);\n</code-example>\n<p>In the above situation we need the observable stream to complete so that we can test the variable was set to the correct value. The TestScheduler runs in 'virtual time' (synchronously), but doesn't normally run (and complete) until the testScheduler callback returns. The flush() method manually triggers the virtual time so that we can test the local variable after the observable completes.</p>\n<p>在上述情况下，我们需要完成 observable 流，以便我们可以测试变量是否已设置为正确的值。TestScheduler 在“虚拟时间”中（同步）运行，但在 testScheduler 回调返回之前通常不会运行（并完成）。flush() 方法会手动触发虚拟时间，以便我们可以在 observable 完成后测试局部变量。</p>\n<hr>\n<h2 id=\"known-issues\">Known issues<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#known-issues\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"已知的问题\">已知的问题<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#已知的问题\"><i class=\"material-icons\">link</i></a></h2>\n<h3 id=\"rxjs-code-that-consumes-promises-cannot-be-directly-tested\">RxJS code that consumes Promises cannot be directly tested<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#rxjs-code-that-consumes-promises-cannot-be-directly-tested\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"使用-promises-的-rxjs-代码无法直接测试\">使用 Promises 的 RxJS 代码无法直接测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#使用-promises-的-rxjs-代码无法直接测试\"><i class=\"material-icons\">link</i></a></h3>\n<p>If you have RxJS code that uses asynchronous scheduling - e.g. Promises, etc. - you can't reliably use marble diagrams <em>for that particular code</em>. This is because those other scheduling methods won't be virtualized or known to TestScheduler.</p>\n<p>如果你有使用异步调度的 RxJS 代码（例如 Promises 等）你不能可靠地<em>为那部分代码</em>使用弹珠图。这是因为另外那些调度方法不会被虚拟化或不了解 TestScheduler。</p>\n<p>The solution is to test that code in isolation, with the traditional asynchronous testing methods of your testing framework. The specifics depend on your testing framework of choice, but here's a pseudo-code example:</p>\n<p>解决方案是使用测试框架的传统异步测试方法单独测试该代码。具体细节取决于你选择的测试框架，但这里有一个伪代码示例：</p>\n<code-example language=\"ts\">\n// Some RxJS code that also consumes a Promise, so <a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a> won't be able\n// to correctly virtualize and the test will always be really asynchronous.\nconst myAsyncCode = () => <a href=\"api/index/function/from\" class=\"code-anchor\">from</a>(Promise.resolve('something'));\n\nit('has async code', (done) => {\n  myAsyncCode().subscribe((d) => {\n    assertEqual(d, 'something');\n    done();\n  });\n});\n</code-example>\n<p>On a related note, you also can't currently assert delays of zero, even with <code>AsyncScheduler</code>, e.g. <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a>(0)</code> is like saying <code>setTimeout(work, 0)</code>. This schedules a new <a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\">\"task\" aka \"macrotask\"</a>, so it's asynchronous, but without an explicit passage of time.</p>\n<p>一个相关说明：你目前也无法断言延迟为零，即使用的是 <code>AsyncScheduler</code>，例如 <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a>(0)</code> 也就是 <code>setTimeout(work, 0)</code>。这会安排一个新的<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\">“任务”也叫“宏任务”</a>，所以它是异步的，但没有明确的时间流逝。</p>\n<h3 id=\"behavior-is-different-outside-of-testschedulerruncallback\">Behavior is different outside of <code>testScheduler.run(callback)</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#behavior-is-different-outside-of-testschedulerruncallback\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"在-testschedulerruncallback-之外的行为有些差异\">在 <code>testScheduler.run(callback)</code> 之外的行为有些差异<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/testing/marble-testing#在-testschedulerruncallback-之外的行为有些差异\"><i class=\"material-icons\">link</i></a></h3>\n<p>The <code><a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a></code> has been around since v5, but was actually intended for testing RxJS itself by the maintainers, rather than for use in regular user apps. Because of this, some of the default behaviors and features of the TestScheduler did not work well (or at all) for users. In v6 we introduced the <code>testScheduler.run(callback)</code> method which allowed us to provide new defaults and features in a non-breaking way, but it's still possible\nto <a href=\"https://github.com/ReactiveX/rxjs/blob/7113ae4b451dd8463fae71b68edab96079d089df/docs_app/content/guide/testing/internal-marble-tests.md\">use the TestScheduler outside</a> of <code>testScheduler.run(callback)</code>. It's important to note that if you do so, there are some major differences in how it will behave.</p>\n<p><code><a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a></code> 从 v5 开始就已经存在，但实际上是供维护人员测试 RxJS 本身准备的，而不是让普通用户在应用程序中使用。正因为如此，TestScheduler 的一些默认行为和功能对用户来说效果不佳（或根本不工作）。在 v6 中，我们引入了 <code>testScheduler.run(callback)</code> 方法，它允许我们以非破坏性的方式提供新的默认值和特性，但仍然可以在 <code>testScheduler.run(callback)</code> <a href=\"https://github.com/ReactiveX/rxjs/blob/7113ae4b451dd8463fae71b68edab96079d089df/docs_app/content/guide/testing/internal-marble-tests.md\">之外使用 TestScheduler</a>。重要的是要注意，如果你这样做，它的行为方式会有一些重大差异。</p>\n<ul>\n<li>\n<p><code><a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a></code> helper methods have more verbose names, like <code>testScheduler.createColdObservable()</code> instead of <code>cold()</code>.</p>\n<p><code><a href=\"api/testing/TestScheduler\" class=\"code-anchor\">TestScheduler</a></code> 辅助方法具有更冗长的名称，例如 <code>testScheduler.createColdObservable()</code> 而不是 <code>cold()</code>。</p>\n</li>\n<li>\n<p>The testScheduler instance is <em>not</em> automatically used by operators that use <code>AsyncScheduler</code>, e.g. <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code>, <code><a href=\"api/index/function/debounceTime\" class=\"code-anchor\">debounceTime</a></code>, etc., so you have to explicitly pass it to them.</p>\n<p>使用 AsyncScheduler 的操作符<em>不会</em>自动使用 <code>AsyncScheduler</code> 实例，例如 <code><a href=\"api/index/function/delay\" class=\"code-anchor\">delay</a></code>、<code><a href=\"api/index/function/debounceTime\" class=\"code-anchor\">debounceTime</a></code> 等，因此你必须将其显式传递给它们。</p>\n</li>\n<li>\n<p>There is NO support for time progression syntax e.g. <code>-a 100ms b-|</code>.</p>\n<p>不支持时间进度语法，例如 <code>-a 100ms b-|</code> .</p>\n</li>\n<li>\n<p>1 frame is 10 virtual milliseconds by default. i.e. <code><a href=\"api/testing/TestScheduler#frameTimeFactor\" class=\"code-anchor\">TestScheduler.frameTimeFactor</a> = 10</code>.</p>\n<p>1 帧默认为 10 个虚拟毫秒。即 <code><a href=\"api/testing/TestScheduler#frameTimeFactor\" class=\"code-anchor\">TestScheduler.frameTimeFactor</a> = 10</code>。</p>\n</li>\n<li>\n<p>Each whitespace <code>' '</code> equals 1 frame, same as a hyphen <code>'-'</code>.</p>\n<p>每个空格 <code>' '</code> 等于 1 帧，与连字符 <code>'-'</code> 相同。</p>\n</li>\n<li>\n<p>There is a hard maximum number of frames set at 750 i.e. <code>maxFrames = 750</code>. After 750 they are silently ignored.</p>\n<p>有一个硬性的最大帧数设置为 750 即 <code>maxFrames = 750</code>。在 750 之后，它们会被默默地忽略。</p>\n</li>\n<li>\n<p>You must explicitly flush the scheduler.</p>\n<p>你必须显式刷新调度器。</p>\n</li>\n</ul>\n<p>While at this time usage of the TestScheduler outside of <code>testScheduler.run(callback)</code> has not been officially deprecated, it is discouraged because it is likely to cause confusion.</p>\n<p>虽然此时在 <code>testScheduler.run(callback)</code> 之外使用 TestScheduler 尚未被正式弃用，但不鼓励这样做，因为它可能会引起混淆。</p>\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/index/class/Observable\n - api/index/const/EMPTY\n - api/index/const/NEVER\n - api/index/function/concatMap\n - api/index/function/debounceTime\n - api/index/function/delay\n - api/index/function/from\n - api/index/function/interval\n - api/index/function/mapTo\n - api/index/function/of\n - api/index/function/repeat\n - api/index/function/tap\n - api/index/function/throttleTime\n - api/index/function/throwError\n - api/index/function/using\n - api/testing/TestScheduler\n - api/testing/TestScheduler#frameTimeFactor\n - guide/testing/marble-testing#api\n - guide/testing/marble-testing#behavior-is-different-outside-of-testschedulerruncallback\n - guide/testing/marble-testing#examples\n - guide/testing/marble-testing#examples-1\n - guide/testing/marble-testing#known-issues\n - guide/testing/marble-testing#marble-syntax\n - guide/testing/marble-testing#rxjs-code-that-consumes-promises-cannot-be-directly-tested\n - guide/testing/marble-testing#subscription-marbles\n - guide/testing/marble-testing#synchronous-assertion\n - guide/testing/marble-testing#testing-rxjs-code-with-marble-diagrams\n - guide/testing/marble-testing#time-progression-syntax\n - guide/testing/marble-testing#使用-promises-的-rxjs-代码无法直接测试\n - guide/testing/marble-testing#例子\n - guide/testing/marble-testing#例子-1\n - guide/testing/marble-testing#同步断言\n - guide/testing/marble-testing#在-testschedulerruncallback-之外的行为有些差异\n - guide/testing/marble-testing#已知的问题\n - guide/testing/marble-testing#弹珠语法\n - guide/testing/marble-testing#时间进展语法\n - guide/testing/marble-testing#用弹珠图测试-rxjs-代码\n - guide/testing/marble-testing#订阅弹珠\n - https://github.com/ReactiveX/rxjs/blob/7113ae4b451dd8463fae71b68edab96079d089df/docs_app/content/guide/testing/internal-marble-tests.md\n - https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n - https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\n-->"
}