{
  "id": "deprecations/to-promise",
  "title": "Conversion to Promises",
  "contents": "\n<div class=\"content\">\n<h1 id=\"conversion-to-promises\">Conversion to Promises<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#conversion-to-promises\"><i class=\"material-icons\">link</i></a></h1>\n<p>The similarity between Observables and Promises is that both <a href=\"/guide/observable\">collections</a> may produce values over\ntime, but the difference is that Observables may produce none or more than one value, while Promises produce only one\nvalue when resolved successfully.</p>\n<h2 id=\"issues\">Issues<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#issues\"><i class=\"material-icons\">link</i></a></h2>\n<p>For this reason, in RxJS 7, the return type of the Observable's <a href=\"/api/index/class/Observable#toPromise\"><code>toPromise()</code></a>\nmethod has been fixed to better reflect the fact that Observables can yield zero values. This may be a <strong>breaking\nchange</strong> to some projects as the return type was changed from <code>Promise&#x3C;T></code> to <code>Promise&#x3C;T | undefined></code>.</p>\n<p>Also, <code>toPromise()</code> method name was never indicating what emitted value a Promise will resolve with because Observables\ncan produce multiple values over time. When converting to a Promise, you might want to choose which value to pick -\neither the first value that has arrived or the last one. To fix all these issues, we decided to deprecate <code>toPromise()</code>,\nand to introduce the two new helper functions for conversion to Promises.</p>\n<h2 id=\"use-one-of-the-two-new-functions\">Use one of the two new functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#use-one-of-the-two-new-functions\"><i class=\"material-icons\">link</i></a></h2>\n<p>As a replacement to the deprecated <code>toPromise()</code> method, you should use one of the two built in static conversion\nfunctions <a href=\"api/index/function/firstValueFrom\"><code>firstValueFrom</code></a> or <a href=\"api/index/function/lastValueFrom\"><code>lastValueFrom</code></a>.</p>\n<h3 id=\"lastvaluefrom\"><code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#lastvaluefrom\"><i class=\"material-icons\">link</i></a></h3>\n<p>The <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> is almost exactly the same as <code>toPromise()</code> meaning that it will resolve with the last value that has\narrived when the Observable completes, but with the difference in behavior when Observable completes without emitting a\nsingle value. When Observable completes without emitting, <code>toPromise()</code> will successfully resolve with <code>undefined</code> (thus\nthe return type change), while the <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> will reject with the <a href=\"api/index/class/EmptyError\"><code>EmptyError</code></a>. Thus, the return type of the\n<code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> is <code>Promise&#x3C;T></code>, just like <code>toPromise()</code> had in RxJS 6.</p>\n<h4 id=\"example\">Example<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#example\"><i class=\"material-icons\">link</i></a></h4>\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>, <a href=\"api/index/function/take\" class=\"code-anchor\">take</a>, <a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a> } from 'rxjs';\n\nasync function execute() {\n  const source$ = <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>(2000).pipe(<a href=\"api/index/function/take\" class=\"code-anchor\">take</a>(10));\n  const finalNumber = await <a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a>(source$);\n  console.log(`The final number is ${finalNumber}`);\n}\n\nexecute();\n\n// Expected output:\n// \"The final number is 9\"\n</code-example>\n<h3 id=\"firstvaluefrom\"><code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#firstvaluefrom\"><i class=\"material-icons\">link</i></a></h3>\n<p>However, you might want to take the first value as it arrives without waiting an Observable to complete, thus you can\nuse <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code>. The <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> will resolve a Promise with the first value that was emitted from the\nObservable and will immediately unsubscribe to retain resources. The <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> will also reject with an\n<a href=\"api/index/class/EmptyError\"><code>EmptyError</code></a> if the Observable completes with no values emitted.</p>\n<h4 id=\"example-1\">Example<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#example-1\"><i class=\"material-icons\">link</i></a></h4>\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>, <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a> } from 'rxjs';\n\nasync function execute() {\n  const source$ = <a href=\"api/index/function/interval\" class=\"code-anchor\">interval</a>(2000);\n  const firstNumber = await <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a>(source$);\n  console.log(`The <a href=\"api/index/function/first\" class=\"code-anchor\">first</a> number is ${firstNumber}`);\n}\n\nexecute();\n\n// Expected output:\n// \"The <a href=\"api/index/function/first\" class=\"code-anchor\">first</a> number is 0\"\n</code-example>\n<p><span class=\"informal\">Both functions will return a Promise that rejects if the source Observable errors. The Promise\nwill reject with the same error that the Observable has errored with.</span></p>\n<h2 id=\"use-default-value\">Use default value<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#use-default-value\"><i class=\"material-icons\">link</i></a></h2>\n<p>If you don't want Promises created by <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> or <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> to reject with <a href=\"api/index/class/EmptyError\"><code>EmptyError</code></a> if there\nwere no emissions before completion, you can use the second parameter. The second parameter is expected to be an object\nwith <code>defaultValue</code> parameter. The value in the <code>defaultValue</code> will be used to resolve a Promise when source Observable\ncompletes without emitted values.</p>\n<code-example language=\"ts\">\nimport { <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a>, <a href=\"api/index/const/EMPTY\" class=\"code-anchor\">EMPTY</a> } from 'rxjs';\n\nconst result = await <a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a>(<a href=\"api/index/const/EMPTY\" class=\"code-anchor\">EMPTY</a>, { defaultValue: 0 });\nconsole.log(result);\n\n// Expected output:\n// 0\n</code-example>\n<h2 id=\"warning\">Warning<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"deprecations/to-promise#warning\"><i class=\"material-icons\">link</i></a></h2>\n<p>Only use <code><a href=\"api/index/function/lastValueFrom\" class=\"code-anchor\">lastValueFrom</a></code> function if you <em>know</em> an Observable will eventually complete. The <code><a href=\"api/index/function/firstValueFrom\" class=\"code-anchor\">firstValueFrom</a></code> function should\nbe used if you <em>know</em> an Observable will emit at least one value <em>or</em> will eventually complete. If the source Observable\ndoes not complete or emit, you will end up with a Promise that is hung up, and potentially all of the state of an async\nfunction hanging out in memory. To avoid this situation, look into adding something like <a href=\"api/index/function/timeout\"><code>timeout</code></a>, <a href=\"api/index/function/take\"><code>take</code></a>,\n<a href=\"api/index/function/takeWhile\"><code>takeWhile</code></a>, or <a href=\"api/index/function/takeUntil\"><code>takeUntil</code></a> amongst others.</p>\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - /api/index/class/Observable#toPromise\n - /guide/observable\n - api/index/class/EmptyError\n - api/index/const/EMPTY\n - api/index/function/first\n - api/index/function/firstValueFrom\n - api/index/function/interval\n - api/index/function/lastValueFrom\n - api/index/function/take\n - api/index/function/takeUntil\n - api/index/function/takeWhile\n - api/index/function/timeout\n - deprecations/to-promise#conversion-to-promises\n - deprecations/to-promise#example\n - deprecations/to-promise#example-1\n - deprecations/to-promise#firstvaluefrom\n - deprecations/to-promise#issues\n - deprecations/to-promise#lastvaluefrom\n - deprecations/to-promise#use-default-value\n - deprecations/to-promise#use-one-of-the-two-new-functions\n - deprecations/to-promise#warning\n-->"
}